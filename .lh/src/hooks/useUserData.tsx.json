{
    "sourceFile": "src/hooks/useUserData.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1748370250224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1749127234757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,9 +208,9 @@\n           }))\r\n         );\r\n       } else {\r\n         // Loggez que nous n'avons pas trouvé de services\r\n-        console.log(\"Aucun service trouvé pour cet utilisateur\");\r\n+        // console.log(\"Aucun service trouvé pour cet utilisateur\");\r\n         setUserServices([]);\r\n       }\r\n \r\n       // Pour les fonctionnalités qui ne sont pas encore implémentées dans la base de données,\r\n"
                }
            ],
            "date": 1748370250224,
            "name": "Commit-0",
            "content": "\r\nimport { useEffect, useState } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { toast } from '@/components/ui/use-toast';\r\n\r\nexport interface UserProfile {\r\n  id: string;\r\n  email: string;\r\n  first_name: string;\r\n  last_name: string;\r\n  created_at: string;\r\n  company_name?: string;\r\n  phone?: string;\r\n}\r\n\r\nexport interface UserDomiciliation {\r\n  id?: string;\r\n  user_id?: string;\r\n  status: 'active' | 'inactive' | 'pending';\r\n  address: string;\r\n  renewal_date: string;\r\n  created_at?: string;\r\n  plan_type?: string; // Type de plan: 'société', 'auto-entrepreneur', 'association'\r\n  duration?: string; // '1 mois', '3 mois', '6 mois', '1 an'\r\n}\r\n\r\nexport interface UserService {\r\n  id: string;\r\n  user_id?: string;\r\n  name: string;\r\n  status: 'active' | 'inactive' | 'pending' | 'option';\r\n  price?: number;\r\n  renewal_date?: string;\r\n  category: 'domiciliation' | 'admin' | 'marketing' | 'complementary';\r\n  created_at?: string;\r\n  updated_at?: string;\r\n}\r\n\r\nexport interface UserMail {\r\n  id: string;\r\n  user_id?: string;\r\n  subject: string;\r\n  received_at: string;\r\n  status: 'new' | 'read';\r\n}\r\n\r\nexport interface UserNotification {\r\n  id: string;\r\n  user_id?: string;\r\n  message: string;\r\n  created_at: string;\r\n  read: boolean;\r\n}\r\n\r\nexport interface UserActivity {\r\n  id: string;\r\n  user_id?: string;\r\n  type: 'mail' | 'document' | 'message';\r\n  title: string;\r\n  description: string;\r\n  created_at: string;\r\n}\r\n\r\nexport interface UserDocument {\r\n  id: string;\r\n  user_id?: string;\r\n  name: string;\r\n  created_at: string;\r\n  type: string;\r\n}\r\n\r\nexport interface UserAdminService {\r\n  id: string;\r\n  user_id?: string;\r\n  service: string;\r\n  next_processing: string;\r\n  status: 'pending' | 'active' | 'completed';\r\n}\r\n\r\nexport function useUserData() {\r\n  const [profile, setProfile] = useState<UserProfile | null>(null);\r\n  const [domiciliation, setDomiciliation] = useState<UserDomiciliation | null>(null);\r\n  const [userServices, setUserServices] = useState<UserService[]>([]);\r\n  const [mails, setMails] = useState<UserMail[]>([]);\r\n  const [notifications, setNotifications] = useState<UserNotification[]>([]);\r\n  const [activities, setActivities] = useState<UserActivity[]>([]);\r\n  const [documents, setDocuments] = useState<UserDocument[]>([]);\r\n  const [adminServices, setAdminServices] = useState<UserAdminService[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const fetchUserData = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Get current session\r\n      const { data: { session } } = await supabase.auth.getSession();\r\n      \r\n      if (!session) {\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      // Fetch user profile from profiles table\r\n      const { data: profileData, error: profileError } = await supabase\r\n        .from('profiles')\r\n        .select('*')\r\n        .eq('id', session.user.id)\r\n        .single();\r\n\r\n      if (profileError) throw profileError;\r\n      \r\n      setProfile({\r\n        id: profileData?.id || session.user.id,\r\n        email: session.user.email || '',\r\n        first_name: profileData?.first_name || '',\r\n        last_name: profileData?.last_name || '',\r\n        company_name: profileData?.company_name || '',\r\n        phone: profileData?.phone || '',\r\n        created_at: profileData?.created_at || session.user.created_at\r\n      });\r\n\r\n      // Récupérer les informations de domiciliation depuis Supabase\r\n      const { data: domiciliationData, error: domiciliationError } = await supabase\r\n        .from('user_domiciliations')\r\n        .select('*')\r\n        .eq('user_id', session.user.id)\r\n        .maybeSingle();\r\n\r\n      if (domiciliationError && domiciliationError.code !== 'PGRST116') {\r\n        // Si c'est une erreur autre que \"No rows found\"\r\n        console.error('Erreur lors de la récupération des informations de domiciliation:', domiciliationError);\r\n      }\r\n\r\n      // Si un enregistrement de domiciliation est trouvé, utilisez-le\r\n      if (domiciliationData) {\r\n        // Assurons-nous que le statut correspond aux valeurs attendues\r\n        const typedStatus = domiciliationData.status as 'active' | 'inactive' | 'pending';\r\n        \r\n        setDomiciliation({\r\n          id: domiciliationData.id,\r\n          user_id: domiciliationData.user_id,\r\n          status: typedStatus,\r\n          address: domiciliationData.address,\r\n          renewal_date: domiciliationData.renewal_date,\r\n          plan_type: domiciliationData.plan_type,\r\n          duration: domiciliationData.duration,\r\n          created_at: domiciliationData.created_at\r\n        });\r\n      } else {\r\n        // Sinon, utilisez des valeurs par défaut\r\n        // console.log('Aucune information de domiciliation trouvée, utilisation des valeurs par défaut');\r\n        setDomiciliation({\r\n          user_id: session.user.id,\r\n          status: 'pending',\r\n          address: 'En attente de validation',\r\n          renewal_date: new Date().toISOString()\r\n        });\r\n      }\r\n\r\n      // Récupérer les services de l'utilisateur depuis Supabase\r\n      const { data: servicesData, error: servicesError } = await supabase\r\n        .from('user_services')\r\n        .select('*')\r\n        .eq('user_id', session.user.id);\r\n\r\n      if (servicesError) {\r\n        console.error('Erreur lors de la récupération des services:', servicesError);\r\n      }\r\n\r\n      // Si des services sont trouvés, utilisez-les\r\n      if (servicesData && servicesData.length > 0) {\r\n        setUserServices(servicesData.map(service => ({\r\n          id: service.id,\r\n          user_id: service.user_id,\r\n          name: service.name,\r\n          // Assurons-nous que le statut correspond aux valeurs attendues\r\n          status: service.status as 'active' | 'inactive' | 'pending' | 'option',\r\n          price: service.price || undefined,\r\n          renewal_date: service.renewal_date,\r\n          // Assurons-nous que la catégorie correspond aux valeurs attendues\r\n          category: service.category as 'domiciliation' | 'admin' | 'marketing' | 'complementary',\r\n          created_at: service.created_at,\r\n          updated_at: service.updated_at\r\n        })));\r\n      } else {\r\n        // Loggez que nous n'avons pas trouvé de services\r\n        console.log('Aucun service trouvé pour cet utilisateur');\r\n        setUserServices([]);\r\n      }\r\n\r\n      // Pour les fonctionnalités qui ne sont pas encore implémentées dans la base de données,\r\n      // nous utilisons des données temporaires\r\n      setMails([\r\n        { id: '1', user_id: session.user.id, subject: 'Impôts - Déclaration TVA', received_at: new Date().toISOString(), status: 'new' },\r\n        { id: '2', user_id: session.user.id, subject: 'Facture Électricité', received_at: new Date(Date.now() - 86400000).toISOString(), status: 'new' },\r\n        { id: '3', user_id: session.user.id, subject: 'Contrat Fournisseur', received_at: new Date(Date.now() - 172800000).toISOString(), status: 'new' },\r\n      ]);\r\n\r\n      setNotifications([\r\n        { id: '1', user_id: session.user.id, message: 'Nouveau courrier reçu', created_at: new Date().toISOString(), read: false },\r\n        { id: '2', user_id: session.user.id, message: 'Document numérisé disponible', created_at: new Date(Date.now() - 86400000).toISOString(), read: false },\r\n      ]);\r\n\r\n      setActivities([\r\n        { \r\n          id: '1', \r\n          user_id: session.user.id,\r\n          type: 'mail', \r\n          title: 'Nouveau courrier reçu', \r\n          description: 'Impôts - Déclaration TVA', \r\n          created_at: new Date().toISOString() \r\n        },\r\n        { \r\n          id: '2', \r\n          user_id: session.user.id,\r\n          type: 'document', \r\n          title: 'Document numérisé', \r\n          description: 'Contrat_Prestation_2025.pdf', \r\n          created_at: new Date(Date.now() - 86400000).toISOString() \r\n        },\r\n        { \r\n          id: '3', \r\n          user_id: session.user.id,\r\n          type: 'message', \r\n          title: 'Message de votre assistant', \r\n          description: 'Mise à jour de vos documents légaux', \r\n          created_at: new Date(Date.now() - 172800000).toISOString() \r\n        },\r\n      ]);\r\n\r\n      setDocuments([\r\n        { id: '1', user_id: session.user.id, name: 'Facture_Mars2025.pdf', created_at: '2025-04-01T10:00:00Z', type: 'Comptabilité' },\r\n        { id: '2', user_id: session.user.id, name: 'PV_AG_2025.pdf', created_at: '2025-03-15T14:30:00Z', type: 'Juridique' },\r\n      ]);\r\n\r\n      // Filtrer les services administratifs depuis les userServices\r\n      const adminServicesList = userServices\r\n        .filter(service => service.category === 'admin')\r\n        .map(service => ({\r\n          id: service.id,\r\n          user_id: service.user_id,\r\n          service: service.name,\r\n          next_processing: service.renewal_date || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\r\n          status: service.status as 'pending' | 'active' | 'completed'\r\n        }));\r\n\r\n      setAdminServices(adminServicesList.length > 0 ? adminServicesList : [\r\n        { id: '1', user_id: session.user.id, service: 'Déclaration TVA', next_processing: '2025-05-05T00:00:00Z', status: 'pending' },\r\n        { id: '2', user_id: session.user.id, service: 'Gestion comptable', next_processing: '2025-04-30T00:00:00Z', status: 'active' },\r\n        { id: '3', user_id: session.user.id, service: 'Secrétariat juridique', next_processing: '2025-05-15T00:00:00Z', status: 'active' },\r\n      ]);\r\n\r\n    } catch (err: any) {\r\n      setError(err.message);\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: \"Impossible de récupérer les informations utilisateur\",\r\n        variant: \"destructive\"\r\n      });\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    fetchUserData();\r\n  }, []);\r\n\r\n  // Function to update user profile\r\n  const updateProfile = async (updatedProfile: Partial<UserProfile>) => {\r\n    try {\r\n      const { error } = await supabase\r\n        .from('profiles')\r\n        .update(updatedProfile)\r\n        .eq('id', profile?.id);\r\n\r\n      if (error) throw error;\r\n      \r\n      // Refresh data\r\n      toast({\r\n        title: \"Succès\",\r\n        description: \"Votre profil a été mis à jour\",\r\n      });\r\n      \r\n      await fetchUserData();\r\n      return true;\r\n    } catch (err: any) {\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: err.message || \"Impossible de mettre à jour le profil\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Function to update domiciliation information\r\n  const updateDomiciliation = async (updatedDomiciliation: Partial<UserDomiciliation>) => {\r\n    try {\r\n      if (domiciliation?.id) {\r\n        // Mise à jour d'une domiciliation existante\r\n        const { error } = await supabase\r\n          .from('user_domiciliations')\r\n          .update({\r\n            ...updatedDomiciliation,\r\n            updated_at: new Date().toISOString()\r\n          })\r\n          .eq('id', domiciliation.id);\r\n\r\n        if (error) throw error;\r\n      } else {\r\n        // Création d'une nouvelle domiciliation\r\n        const { error } = await supabase\r\n          .from('user_domiciliations')\r\n          .insert({\r\n            ...updatedDomiciliation,\r\n            address: updatedDomiciliation.address || 'En attente de validation',\r\n            user_id: profile?.id\r\n          });\r\n\r\n        if (error) throw error;\r\n      }\r\n      \r\n      toast({\r\n        title: \"Succès\",\r\n        description: \"Informations de domiciliation mises à jour\",\r\n      });\r\n      \r\n      await fetchUserData();\r\n      return true;\r\n    } catch (err: any) {\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: err.message || \"Impossible de mettre à jour les informations de domiciliation\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Add or update a user service\r\n  const updateUserService = async (service: Partial<UserService>) => {\r\n    try {\r\n      if (service.id) {\r\n        // Mise à jour d'un service existant\r\n        const { error } = await supabase\r\n          .from('user_services')\r\n          .update({\r\n            ...service,\r\n            updated_at: new Date().toISOString()\r\n          })\r\n          .eq('id', service.id);\r\n\r\n        if (error) throw error;\r\n      } else {\r\n        // Création d'un nouveau service\r\n        const { error } = await supabase\r\n          .from('user_services')\r\n          .insert({\r\n            name: service.name || '',\r\n            category: service.category || 'domiciliation',\r\n            status: service.status || 'active',\r\n            user_id: profile?.id\r\n          });\r\n\r\n        if (error) throw error;\r\n      }\r\n      \r\n      toast({\r\n        title: \"Succès\",\r\n        description: \"Service mis à jour avec succès\",\r\n      });\r\n      \r\n      await fetchUserData();\r\n      return true;\r\n    } catch (err: any) {\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: err.message || \"Impossible de mettre à jour le service\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Function to mark mail as read\r\n  const markMailAsRead = async (mailId: string) => {\r\n    try {\r\n      // In a production app, we would update the mail in Supabase\r\n      // For now, we'll just update the state\r\n      setMails(prev => prev.map(mail => \r\n        mail.id === mailId ? { ...mail, status: 'read' } : mail\r\n      ));\r\n      \r\n      return true;\r\n    } catch (err: any) {\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: \"Impossible de marquer le courrier comme lu\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  // Function to mark notification as read\r\n  const markNotificationAsRead = async (notificationId: string) => {\r\n    try {\r\n      // In a production app, we would update the notification in Supabase\r\n      // For now, we'll just update the state\r\n      setNotifications(prev => prev.map(notification => \r\n        notification.id === notificationId ? { ...notification, read: true } : notification\r\n      ));\r\n      \r\n      return true;\r\n    } catch (err: any) {\r\n      toast({\r\n        title: \"Erreur\",\r\n        description: \"Impossible de marquer la notification comme lue\",\r\n        variant: \"destructive\"\r\n      });\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    profile,\r\n    domiciliation,\r\n    userServices,\r\n    mails,\r\n    notifications,\r\n    activities,\r\n    documents,\r\n    adminServices,\r\n    loading,\r\n    error,\r\n    updateProfile,\r\n    updateDomiciliation,\r\n    updateUserService,\r\n    markMailAsRead,\r\n    markNotificationAsRead,\r\n    refreshUserData: fetchUserData\r\n  };\r\n}\r\n"
        }
    ]
}